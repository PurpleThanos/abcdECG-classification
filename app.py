import streamlit as st
import numpy as np
import cv2
from PIL import Image
from tensorflow.keras.models import load_model
import datetime
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch
from io import BytesIO

# ================= Styling ====================
st.set_page_config(page_title="ECG Classifier", page_icon="ü©∫", layout="centered")

st.markdown("""
    <style>
        body, .stApp {
            background-color: #ffffff;
            font-family: 'Segoe UI', sans-serif;
            color: #185eaf;
        }

        h1, h2, h3, h4, h5, h6, p, div, span {
            color: #185eaf !important;
        }

        .stButton>button, .stDownloadButton>button {
            background-color: #add8e6;
            color: #003366;
            border: none;
            padding: 0.5em 1.5em;
            font-weight: bold;
            border-radius: 8px;
        }

        .stButton>button:hover, .stDownloadButton>button:hover {
            background-color: #87ceeb;
            color: #002244;
        }

        .stAlert {
            background-color: #ffecec;
            color: #9f2d2a !important;
        }
    </style>
""", unsafe_allow_html=True)

# ================= Load Model ====================
model = load_model("ecg_model.h5")
class_names = ['Myocardial Infarction', 'History of MI', 'Abnormal Heartbeat', 'Normal']

# ================= Functions ====================
def is_ecg_image(image):
    image_np = np.array(image.convert('RGB'))
    gray = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)
    edges = cv2.Canny(gray, 50, 150)
    edge_density = np.sum(edges > 0) / (edges.shape[0] * edges.shape[1])
    return edge_density > 0.04

def predict(image):
    image_np = np.array(image)
    if image_np.shape[-1] == 4:
        image_np = image_np[..., :3]
    image_bgr = cv2.cvtColor(image_np, cv2.COLOR_RGB2BGR)
    image_resized = cv2.resize(image_bgr, (224, 224))
    image_rgb = cv2.cvtColor(image_resized, cv2.COLOR_BGR2RGB)
    img_array = image_rgb.astype('float32') / 255.0
    img_array = np.expand_dims(img_array, axis=0)
    preds = model.predict(img_array)[0]
    return preds

def generate_pdf_report(filename, predicted_class, confidence):
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=A4)
    width, height = A4

    c.setFont("Helvetica-Bold", 20)
    c.drawString(1 * inch, height - 1 * inch, "ECG Diagnosis Report")

    c.setFont("Helvetica", 12)
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    c.drawString(1 * inch, height - 1.5 * inch, f"Date: {now}")
    c.drawString(1 * inch, height - 1.8 * inch, f"File: {filename}")
    c.drawString(1 * inch, height - 2.1 * inch, f"Prediction: {predicted_class}")
    c.drawString(1 * inch, height - 2.4 * inch, f"Confidence: {confidence*100:.2f}%")

    c.setFont("Helvetica-Oblique", 11)
    recommendation = "‚úÖ High confidence in prediction." if confidence > 0.8 else "‚ö†Ô∏è Low confidence ‚Äî clinical review advised."
    c.drawString(1 * inch, height - 3.0 * inch, "Interpretation:")
    c.setFont("Helvetica", 12)
    c.drawString(1.2 * inch, height - 3.3 * inch, recommendation)

    c.setFont("Helvetica-Oblique", 9)
    c.drawString(1 * inch, 0.8 * inch, "Generated by: AI ECG Classifier System")
    c.showPage()
    c.save()
    buffer.seek(0)
    return buffer

# ================= UI ====================
st.title("ü©∫ ECG Image Classifier")
st.write("Upload an ECG image below. Our AI will predict your heart condition and generate a downloadable medical report.")

st.markdown("#### üìÇ Upload Your ECG Image")
uploaded_file = st.file_uploader("", type=["jpg", "jpeg", "png"])

# ================= Prediction Workflow ====================
if uploaded_file is not None:
    image = Image.open(uploaded_file)
    st.image(image, caption="üì∏ ECG Image Preview", use_container_width=True)

    if not is_ecg_image(image):
        st.error("‚ùå This image does not appear to be a valid ECG waveform.")
        st.stop()

    st.write("üîé Classifying...")
    predictions = predict(image)
    top_class_index = np.argmax(predictions)
    top_class = class_names[top_class_index]
    confidence = predictions[top_class_index]

    st.subheader(f"‚ù§Ô∏è Prediction: **{top_class}**")
    if confidence < 0.6:
        st.warning("‚ö†Ô∏è Model is not confident enough in this prediction.")

    st.write("### Confidence Breakdown:")
    for i, class_name in enumerate(class_names):
        st.write(f"- **{class_name}**: `{predictions[i]*100:.2f}%`")

    # Report download
    pdf_buffer = generate_pdf_report(uploaded_file.name, top_class, confidence)
    st.download_button(
        label="üì• Download Diagnosis Report (.pdf)",
        data=pdf_buffer,
        file_name=f"{top_class}_report.pdf",
        mime="application/pdf"
    )
